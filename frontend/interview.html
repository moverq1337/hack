<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>HR Avatar - –°–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–µ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
        }
        .vacancy-info {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .question {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            min-height: 2.2em;
        }
        .controls {
            margin: 20px 0;
            text-align: center;
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            margin: 10px;
            cursor: pointer;
            border: none;
            border-radius: 50px;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        button:disabled {
            background: #999;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .progress {
            margin: 20px 0;
            text-align: center;
            font-size: 18px;
        }
        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin: 10px 0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            width: 0%;
            transition: width 0.5s ease;
        }
        .status {
            text-align: center;
            margin: 20px 0;
            font-style: italic;
            min-height: 1.5em;
        }
        .results {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
        }
        .answer {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        .pulse {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>ü§ñ HR Avatar - –°–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–µ</h1>

    <div id="vacancyInfo" class="vacancy-info"></div>

    <div id="interview" style="display: none;">
        <div class="progress">
            –í–æ–ø—Ä–æ—Å <span id="currentQuestion">1</span> –∏–∑ <span id="totalQuestions">1</span>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="question" id="questionText"></div>

        <div class="status" id="status">–û–∂–∏–¥–∞–Ω–∏–µ –Ω–∞—á–∞–ª–∞ –∏–Ω—Ç–µ—Ä–≤—å—é‚Ä¶</div>

        <div class="controls">
            <button id="recordBtn" disabled>üé§ –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å –æ—Ç–≤–µ—Ç–∞</button>
            <button id="stopBtn" style="display: none;">‚èπÔ∏è –ó–∞–≤–µ—Ä—à–∏—Ç—å –æ—Ç–≤–µ—Ç</button>
        </div>

        <div id="processing" style="display: none; text-align: center;">
            <div style="font-size: 24px; margin: 20px;">üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–∞—à –æ—Ç–≤–µ—Ç...</div>
            <div class="pulse">–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ</div>
        </div>
    </div>

    <div id="results" style="display: none;">
        <h2>üéØ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è</h2>
        <div class="progress">
            –û–±—â–∏–π –±–∞–ª–ª: <span id="totalScore">0</span>/100
        </div>
        <div id="resultsContent"></div>
        <button id="restartBtn">üîÑ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
        <button id="backBtn">üìã –ö —Å–ø–∏—Å–∫—É –≤–∞–∫–∞–Ω—Å–∏–π</button>
    </div>
</div>

<script>
    'use strict';

    let websocket = null;
    let mediaRecorder = null;
    let recorderStream = null;
    let audioChunks = [];
    let sessionId = null;
    let isRecording = false;

    let vacancy = null;
    let resume = null;

    const UI = {
        vacancyInfo: document.getElementById('vacancyInfo'),
        interview: document.getElementById('interview'),
        questionText: document.getElementById('questionText'),
        currentQuestion: document.getElementById('currentQuestion'),
        totalQuestions: document.getElementById('totalQuestions'),
        progressFill: document.getElementById('progressFill'),
        status: document.getElementById('status'),
        recordBtn: document.getElementById('recordBtn'),
        stopBtn: document.getElementById('stopBtn'),
        processing: document.getElementById('processing'),
        results: document.getElementById('results'),
        totalScore: document.getElementById('totalScore'),
        resultsContent: document.getElementById('resultsContent'),
        restartBtn: document.getElementById('restartBtn'),
        backBtn: document.getElementById('backBtn')
    };

    // === –£—Ç–∏–ª–∏—Ç—ã UI ===
    function setStatus(text) { UI.status.textContent = text; }
    function setProcessing(on) { UI.processing.style.display = on ? 'block' : 'none'; }
    function setRecordEnabled(enabled) { UI.recordBtn.disabled = !enabled; }
    function showRecordingUI(active) {
        if (active) {
            UI.recordBtn.style.display = 'none';
            UI.stopBtn.style.display = 'inline-block';
        } else {
            UI.recordBtn.style.display = 'inline-block';
            UI.stopBtn.style.display = 'none';
        }
    }
    function updateProgress(number, total) {
        const n = Number(number) || 0, t = Math.max(Number(total) || 1, 1);
        UI.currentQuestion.textContent = String(n);
        UI.totalQuestions.textContent = String(t);
        UI.progressFill.style.width = `${Math.min(100, Math.max(0, (n / t) * 100))}%`;
    }

    // === –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ===
    window.addEventListener('DOMContentLoaded', async () => {
        UI.recordBtn.addEventListener('click', startRecording);
        UI.stopBtn.addEventListener('click', stopRecording);
        UI.restartBtn.addEventListener('click', () => location.reload());
        UI.backBtn.addEventListener('click', () => { window.location.href = 'index.html'; });

        vacancy = safeParseLocalStorage('selectedVacancy');
        resume = safeParseLocalStorage('resumeData');
        const matchScore = localStorage.getItem('matchScore');

        if (!vacancy) {
            window.location.href = 'index.html';
            return;
        }

        UI.vacancyInfo.innerHTML = `
    <h3>${escapeHtml(vacancy.title || '–í–∞–∫–∞–Ω—Å–∏—è')}</h3>
    <p>${escapeHtml(vacancy.company || '')} ‚Ä¢ ${escapeHtml(vacancy.location || '')}</p>
    <p>–°–æ–≤–ø–∞–¥–µ–Ω–∏–µ —Å —Ä–µ–∑—é–º–µ: <strong>${escapeHtml(String(matchScore || '‚Äî'))}%</strong></p>
  `;

        UI.interview.style.display = 'block';
        await startInterview();
    });

    function safeParseLocalStorage(key) {
        try {
            const raw = localStorage.getItem(key);
            return raw ? JSON.parse(raw) : null;
        } catch {
            return null;
        }
    }
    function escapeHtml(s) {
        return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;')
            .replace(/>/g, '&gt;').replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }

    // === WebSocket ===
    async function startInterview() {
        const host = location.hostname || 'localhost';
        const proto = location.protocol === 'https:' ? 'wss://' : 'ws://';
        const port = 8765;
        const WS_URL = `${proto}${host}:${port}`;

        const candidateId = `candidate-${Math.random().toString(36).slice(2, 11)}`;

        setStatus('–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É‚Ä¶');
        setRecordEnabled(false);
        setProcessing(false);
        showRecordingUI(false);

        websocket = new WebSocket(WS_URL);

        websocket.onopen = () => {
            setStatus('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–Ω—Ç–µ—Ä–≤—å—é‚Ä¶');
            websocket.send(JSON.stringify({
                type: 'start_interview',
                candidate_id: candidateId,
                vacancy,
                resume_text: (resume && (resume.content || resume.text || '')) || ''
            }));
        };

        websocket.onmessage = async (event) => {
            let data;
            try { data = JSON.parse(event.data); }
            catch { return console.error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π JSON:', event.data); }

            switch (data.type) {
                case 'question_text':
                    setProcessing(false);
                    setRecordEnabled(false);
                    showRecordingUI(false);
                    sessionId = data.session_id || sessionId;
                    UI.questionText.textContent = data.question || '';
                    updateProgress(data.question_number, data.total_questions);
                    break;

                case 'question_audio':
                    await playQuestionAudio(data.question_audio);
                    // ‚úÖ –†–∞–∑—Ä–µ—à–∞–µ–º –∑–∞–ø–∏—Å—å —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –∞—É–¥–∏–æ
                    setRecordEnabled(true);
                    setStatus('–ì–æ—Ç–æ–≤–æ –∫ –∑–∞–ø–∏—Å–∏ –æ—Ç–≤–µ—Ç–∞');
                    break;

                case 'ready_to_record':
                    setRecordEnabled(true);
                    setStatus('–ì–æ—Ç–æ–≤–æ –∫ –∑–∞–ø–∏—Å–∏ –æ—Ç–≤–µ—Ç–∞');
                    break;

                case 'processing_started':
                    setProcessing(true);
                    setRecordEnabled(false);
                    setStatus('–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞‚Ä¶');
                    break;

                case 'interview_completed':
                    setProcessing(false);
                    showResults(data);
                    break;

                case 'error':
                    setProcessing(false);
                    setRecordEnabled(true);
                    setStatus('–û—à–∏–±–∫–∞: ' + (data.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
                    break;
            }
        };
    }

    // === –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ –≤–æ–ø—Ä–æ—Å–∞ ===
    async function playQuestionAudio(audioBase64) {
        try {
            if (!audioBase64) return;

            const byteStr = atob(audioBase64);
            const bytes = new Uint8Array(byteStr.length);
            for (let i = 0; i < byteStr.length; i++) bytes[i] = byteStr.charCodeAt(i);
            const audioBlob = new Blob([bytes], { type: 'audio/ogg; codecs=opus' });
            const audioUrl = URL.createObjectURL(audioBlob);

            const audio = new Audio(audioUrl);
            setStatus('–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –≤–æ–ø—Ä–æ—Å–∞‚Ä¶');

            await new Promise((resolve) => {
                let finished = false;
                const timer = setTimeout(() => {
                    if (!finished) {
                        console.warn("‚è±Ô∏è Timeout: audio didn't finish");
                        resolve();
                    }
                }, 15000);
                audio.onended = () => {
                    finished = true;
                    clearTimeout(timer);
                    resolve();
                };
                audio.play().catch(err => {
                    console.error("–û—à–∏–±–∫–∞ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏—è:", err);
                    clearTimeout(timer);
                    resolve();
                });
            });

            URL.revokeObjectURL(audioUrl);
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∞—É–¥–∏–æ:', error);
        }
    }

    // === –ó–∞–ø–∏—Å—å –æ—Ç–≤–µ—Ç–∞ ===
    async function startRecording() {
        if (isRecording) return;

        try {
            // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –º–∏–∫—Ä–æ—Ñ–æ–Ω
            recorderStream = await navigator.mediaDevices.getUserMedia({
                audio: { sampleRate: 48000, channelCount: 1 }
            });

            // –í—ã–±–∏—Ä–∞–µ–º –ª—É—á—à–∏–π –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π mimeType
            const preferredTypes = [
                'audio/webm;codecs=opus',
                'audio/webm',
                'audio/ogg;codecs=opus',
                'audio/ogg'
            ];
            let mimeType = '';
            for (const t of preferredTypes) {
                if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) {
                    mimeType = t; break;
                }
            }

            mediaRecorder = new MediaRecorder(recorderStream, mimeType ? { mimeType, audioBitsPerSecond: 128000 } : {});
            audioChunks = [];

            mediaRecorder.ondataavailable = (event) => {
                if (event.data && event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = async () => {
                try {
                    const type = (mimeType || 'audio/webm');
                    const audioBlob = new Blob(audioChunks, { type });
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä base64
                    await sendAudioToServer(audioBlob);
                } catch (err) {
                    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–µ/–æ—Ç–ø—Ä–∞–≤–∫–µ –∞—É–¥–∏–æ:', err);
                    setStatus('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç–≤–µ—Ç–∞');
                } finally {
                    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –º–∏–∫—Ä–æ—Ñ–æ–Ω
                    if (recorderStream) {
                        recorderStream.getTracks().forEach(t => t.stop());
                        recorderStream = null;
                    }
                }
            };

            mediaRecorder.start();
            isRecording = true;

            setRecordEnabled(false);
            showRecordingUI(true);
            setStatus('–ò–¥—ë—Ç –∑–∞–ø–∏—Å—å‚Ä¶ –ì–æ–≤–æ—Ä–∏—Ç–µ —Å–µ–π—á–∞—Å');

        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É:', error);
            alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É');
            setRecordEnabled(true);
            showRecordingUI(false);
            setStatus('–ì–æ—Ç–æ–≤–æ –∫ –∑–∞–ø–∏—Å–∏ –æ—Ç–≤–µ—Ç–∞');
        }
    }

    async function stopRecording() {
        if (!isRecording || !mediaRecorder) return;

        try {
            mediaRecorder.stop();
        } catch (e) {
            console.warn('mediaRecorder.stop() –≤—ã–∑–≤–∞–ª –∏—Å–∫–ª—é—á–µ–Ω–∏–µ:', e);
        }

        isRecording = false;
        showRecordingUI(false);
        setRecordEnabled(true); // –≤—Ä–µ–º–µ–Ω–Ω–æ –±–ª–æ–∫–∏—Ä—É–µ–º —á—É—Ç—å –Ω–∏–∂–µ, –Ω–æ –Ω–∞ —Å–ª—É—á–∞–π –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è —Å–æ–±—ã—Ç–∏–π
        setStatus('–ó–∞–ø–∏—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∞, –æ–±—Ä–∞–±–æ—Ç–∫–∞‚Ä¶');
        // –î–æ –ø—Ä–∏—Ö–æ–¥–∞ processing_started –±–ª–æ–∫–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –Ω–µ –Ω–∞—á–∏–Ω–∞–ª–∏ —Å–ª–µ–¥—É—é—â—É—é –∑–∞–ø–∏—Å—å —Ä–∞–Ω—å—à–µ –≤—Ä–µ–º–µ–Ω–∏
        setRecordEnabled(false);
    }

    // === –û—Ç–ø—Ä–∞–≤–∫–∞ –∞—É–¥–∏–æ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ===
    async function sendAudioToServer(audioBlob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onerror = reject;
            reader.onload = () => {
                try {
                    const base64Audio = String(reader.result).split(',')[1] || '';
                    if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                        throw new Error('–ù–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å —Å–µ—Ä–≤–µ—Ä–æ–º');
                    }
                    websocket.send(JSON.stringify({
                        type: 'audio_response',
                        session_id: sessionId,
                        audio: base64Audio
                    }));
                    resolve(true);
                } catch (e) {
                    reject(e);
                }
            };
            reader.readAsDataURL(audioBlob);
        });
    }

    // === –†–µ–∑—É–ª—å—Ç–∞—Ç—ã ===
    function showResults(data) {
        UI.interview.style.display = 'none';
        UI.results.style.display = 'block';
        UI.totalScore.textContent = (data && typeof data.total_score !== 'undefined')
            ? data.total_score
            : '0';

        const answers = Array.isArray(data?.answers) ? data.answers : [];
        let html = '';

        answers.forEach((answer, idx) => {
            const q = escapeHtml(answer.question || '');
            const a = escapeHtml(answer.answer || '');
            const sc = Number(answer.final_score || 0) * 25; // –∫–∞–∫ –∏ –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –∫–æ–¥–µ
            const conf = Number(answer.confidence || 0) * 100;

            html += `
          <div class="answer">
            <p><strong>–í–æ–ø—Ä–æ—Å ${idx + 1}:</strong> ${q}</p>
            <p><strong>–í–∞—à –æ—Ç–≤–µ—Ç:</strong> ${a}</p>
            <p><strong>–ö–∞—á–µ—Å—Ç–≤–æ –æ—Ç–≤–µ—Ç–∞:</strong> ${sc.toFixed(1)}/25</p>
            <p><em>–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è: ${conf.toFixed(1)}%</em></p>
          </div>
        `;
        });

        UI.resultsContent.innerHTML = html || '<p>–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ –æ—Ç–≤–µ—Ç–∞–º.</p>';
    }
</script>
</body>
</html>
